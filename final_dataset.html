<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Winter Magic - Crystal Clear Version</title>
    <style>
        /* --- Ê≤âÊµ∏ÂºèÊûÅÂ§úËÉåÊôØ --- */
        body { 
            margin: 0; 
            background: radial-gradient(circle at center, #050a14 0%, #000000 100%);
            overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none;
        }
        canvas { display: block; }
        
        /* --- ‰ª™Ë°®ÁõòÊ†∑Âºè --- */
        #dashboard {
            position: absolute; top: 20px; left: 20px;
            padding: 20px; 
            background: rgba(15, 25, 40, 0.7); 
            border: 1px solid rgba(135, 206, 235, 0.2);
            border-left: 4px solid #87CEEB;
            border-radius: 12px; 
            color: #E0FFFF; 
            backdrop-filter: blur(12px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            min-width: 220px;
            z-index: 10;
        }
        #dashboard h3 {
            margin: 0 0 15px 0; font-size: 14px; color: #fff; 
            text-transform: uppercase; letter-spacing: 2px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 5px;
        }
        .stat-row {
            display: flex; justify-content: space-between; margin-bottom: 8px;
            font-family: 'Courier New', monospace; font-size: 13px;
        }
        .val { font-weight: bold; }
        #val-state { color: #87CEEB; text-shadow: 0 0 5px rgba(135, 206, 235, 0.5); transition: color 0.3s; }

        /* --- Èü≥‰πêÊéßÂà∂ --- */
        #music-control {
            position: absolute; top: 20px; right: 20px;
            z-index: 20; cursor: pointer;
            width: 44px; height: 44px;
            border-radius: 50%; background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }
        #music-control:hover { 
            background: rgba(135, 206, 235, 0.15); 
            box-shadow: 0 0 15px rgba(135, 206, 235, 0.3); 
            transform: scale(1.05);
        }
        #music-icon { font-size: 20px; }

        /* --- ÈöêËóèËßÜËßâUI --- */
        #vision-ui {
            display: none;
        }

        /* --- Âä†ËΩΩÈ°µ --- */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050a14; z-index: 999;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 2px solid rgba(135,206,235,0.1);
            border-top-color: #87CEEB; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        .loader-text { color: #87CEEB; font-size: 14px; letter-spacing: 3px; text-transform: uppercase; }
        @keyframes spin { to { transform: rotate(360deg); } }

        audio { display: none; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <audio id="bgm" loop>
        <source src="we_dont_talk_anymore_guitar.mp3" type="audio/mpeg">
        <source src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3" type="audio/mpeg">
    </audio>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Crystal Engine...</div>
    </div>

    <div id="music-control" onclick="toggleMusic()" title="Play BGM">
        <div id="music-icon">üîá</div>
    </div>

    <div id="dashboard">
        <h3>Winter Status</h3>
        <div class="stat-row"><span>Fingers:</span> <span id="ui-fingers" class="val">0</span></div>
        <div class="stat-row"><span>Pinch Dist:</span> <span id="ui-pinch" class="val">0.00</span></div>
        <div class="stat-row"><span>Mode:</span> <span id="val-state" class="val">WAITING</span></div>
        <div style="margin-top:15px; font-size:11px; color:#889; line-height:1.6; border-top: 1px solid rgba(255,255,255,0.05); padding-top:10px;">
            ‚úä <b>Fist:</b> Ice Tree<br>
            üñê <b>Open:</b> Snow Storm<br>
            üëå <b>Pinch:</b> "Merry Xmas"
        </div>
    </div>

    <!-- ÈöêËóè‰ΩÜ‰øùÁïôÁî®‰∫é MediaPipe -->
    <div id="vision-ui">
        <video id="webcam-video" playsinline muted autoplay></video>
        <canvas id="debug-canvas"></canvas>
    </div>

    <script src="https://unpkg.com/gsap@3.12.2/dist/gsap.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        const CONFIG = {
            particleCount: 1500,
            colors: [0xFFFFFF, 0x87CEEB, 0xE0FFFF, 0xB0C4DE],
            bloom: { 
                threshold: 0.25,
                strength: 0.45,
                radius: 0.4
            }
        };

        let scene, camera, renderer, composer, particles, snowSystem;
        let currentState = 'SCATTER';
        let lastTriggerTime = 0;
        let textPoints = [];

        // ================= Èü≥‰πêÊéßÂà∂ =================
        let bgmPlayedOnce = false;
        window.toggleMusic = function() {
            const audio = document.getElementById('bgm');
            const icon = document.getElementById('music-icon');
            if (audio.paused) {
                audio.play().then(() => {
                    icon.innerText = "üé∏";
                    icon.style.color = "#87CEEB";
                    icon.style.textShadow = "0 0 10px #87CEEB";
                }).catch(() => {
                    alert("Audio play failed. Please interact with the page first.");
                });
            } else {
                audio.pause();
                icon.innerText = "üîá";
                icon.style.color = "#fff";
                icon.style.textShadow = "none";
            }
        };

        // ================= Á∫πÁêÜ & Âú∫ÊôØÂàùÂßãÂåñ =================
        function createIceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const cx = 32, cy = 32;
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
            grad.addColorStop(0, 'rgba(255,255,255, 0.9)');
            grad.addColorStop(0.4, 'rgba(200,240,255, 0.5)'); 
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cx, 4); ctx.lineTo(cx, 60);
            ctx.moveTo(4, cy); ctx.lineTo(60, cy);
            ctx.stroke();
            return new THREE.CanvasTexture(canvas);
        }

        function createSnowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,0.8)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        function calculateTextPositions() {
            const canvas = document.createElement('canvas');
            const w = 500; const h = 250;
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.font = '400 65px "Segoe UI", sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Merry", w/2, h/2 - 35);
            ctx.fillText("Christmas", w/2, h/2 + 35);
            const data = ctx.getImageData(0, 0, w, h).data;
            const points = [];
            const step = 4;
            for(let y = 0; y < h; y += step) {
                for(let x = 0; x < w; x += step) {
                    if(data[(y * w + x) * 4 + 3] > 128) {
                        points.push({ x: (x / w - 0.5) * 10, y: -(y / h - 0.5) * 5, z: 0 });
                    }
                }
            }
            return points;
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050a14, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 9);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold
            );
            bloomPass.tintColor = new THREE.Color(0x87CEEB);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());

            const geo = new THREE.BufferGeometry();
            const pos = [], cols = [], sizes = [];
            const colorHelper = new THREE.Color();
            for(let i=0; i<CONFIG.particleCount; i++) {
                pos.push((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*10);
                colorHelper.setHex(CONFIG.colors[Math.floor(Math.random()*CONFIG.colors.length)]);
                cols.push(colorHelper.r, colorHelper.g, colorHelper.b);
                sizes.push(Math.random());
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                size: 0.25,
                map: createIceTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);

            initSnow();
            textPoints = calculateTextPositions();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function initSnow() {
            const snowCount = 350;
            const geo = new THREE.BufferGeometry();
            const pos = [], vels = [];
            for(let i=0; i<snowCount; i++) {
                pos.push((Math.random()-0.5)*25, (Math.random()-0.5)*25, (Math.random()-0.5)*10 - 5);
                vels.push(0.01 + Math.random() * 0.03);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(vels, 1));
            const mat = new THREE.PointsMaterial({
                size: 0.1,
                map: createSnowTexture(),
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function transformTo(shape) {
            if (currentState === shape) return;
            currentState = shape;
            const stateEl = document.getElementById('val-state');
            if (shape === 'GRID') {
                stateEl.innerText = "MERRY XMAS";
                stateEl.style.color = "#FF69B4";
            } else {
                stateEl.innerText = shape;
                stateEl.style.color = shape === 'TREE' ? '#FFD700' : '#87CEEB';
            }

            const positions = particles.geometry.attributes.position.array;
            const indices = Array.from({length: CONFIG.particleCount}, (_, i) => i);
            indices.sort(() => Math.random() - 0.5);

            for(let i=0; i<CONFIG.particleCount; i++) {
                const pIndex = indices[i];
                let tx, ty, tz;
                if (shape === 'TREE') {
                    const t = i / CONFIG.particleCount;
                    const angle = t * Math.PI * 26;
                    const radius = (1 - t) * 3.2;
                    tx = Math.cos(angle) * radius;
                    ty = (t * 9) - 4.5;
                    tz = Math.sin(angle) * radius;
                } else if (shape === 'GRID') {
                    if (i < textPoints.length) {
                        ({x: tx, y: ty, z: tz} = textPoints[i]);
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const r = 7 + Math.random() * 2;
                        tx = Math.cos(angle) * r;
                        ty = Math.sin(angle) * r;
                        tz = (Math.random()-0.5) * 4;
                    }
                } else {
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = 5 + Math.random() * 3;
                    tx = r * Math.sin(phi) * Math.cos(theta);
                    ty = r * Math.sin(phi) * Math.sin(theta);
                    tz = r * Math.cos(phi);
                }
                const idx = pIndex * 3;
                const temp = { x: positions[idx], y: positions[idx+1], z: positions[idx+2] };
                gsap.to(temp, {
                    x: tx, y: ty, z: tz,
                    duration: 1.5 + Math.random() * 1.5,
                    ease: "power3.inOut",
                    onUpdate: () => {
                        positions[idx] = temp.x;
                        positions[idx+1] = temp.y;
                        positions[idx+2] = temp.z;
                    }
                });
            }
        }

        // ================= ËßÜËßâËØÜÂà´ÔºàÊó†UIÔºâ =================
        function initVision() {
            const video = document.getElementById('webcam-video');
            const canvas = document.getElementById('debug-canvas');

            const hands = new Hands({
                locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults(results => {
                // ‰∏çÁªòÂà∂‰ªª‰ΩïÂÜÖÂÆπÂà∞ canvas
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    analyzeGesture(lm);

                    // È¶ñÊ¨°ÊàêÂäüËØÜÂà´Âç≥Â∞ùËØïÊí≠Êîæ BGMÔºàÊª°Ë∂≥ÊµèËßàÂô®Á≠ñÁï•Ôºâ
                    if (!bgmPlayedOnce) {
                        bgmPlayedOnce = true;
                        const audio = document.getElementById('bgm');
                        audio.play().catch(() => {
                            // Ëá™Âä®Êí≠ÊîæÂ§±Ë¥•ÔºåÁî®Êà∑ÈúÄÊâãÂä®ÁÇπÂáª
                        });
                    }
                }
            });

            const cameraObj = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 320, height: 240
            });

            cameraObj.start()
                .then(() => {
                    const loader = document.getElementById('loader');
                    loader.style.opacity = 0;
                    setTimeout(() => loader.style.display = 'none', 800);
                })
                .catch(err => {
                    console.error(err);
                    document.querySelector('.loader-text').innerText = "Cam Error: Need HTTPS";
                });
        }

        function analyzeGesture(lm) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let fingersUp = 0;
            tips.forEach((tip, i) => {
                if (lm[tip].y < lm[pips[i]].y) fingersUp++;
            });
            const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            document.getElementById('ui-fingers').innerText = fingersUp;
            document.getElementById('ui-pinch').innerText = d.toFixed(2);

            const now = Date.now();
            if (now - lastTriggerTime < 800) return;

            if (d < 0.05) {
                transformTo('GRID');
                lastTriggerTime = now;
            } else if (fingersUp <= 0) {
                transformTo('TREE');
                lastTriggerTime = now;
            } else if (fingersUp >= 4) {
                transformTo('SCATTER');
                lastTriggerTime = now;
            }
        }

        // ================= Âä®ÁîªÂæ™ÁéØ =================
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (particles) {
                particles.rotation.y += 0.003;
                const sizes = particles.geometry.attributes.size.array;
                for(let i=0; i<CONFIG.particleCount; i++) {
                    sizes[i] = 0.5 + Math.sin(time * 2.0 + i * 0.1) * 0.3;
                }
                particles.geometry.attributes.size.needsUpdate = true;
                particles.geometry.attributes.position.needsUpdate = true;
            }

            if (snowSystem) {
                const pos = snowSystem.geometry.attributes.position.array;
                const vels = snowSystem.geometry.attributes.velocity.array;
                const count = pos.length / 3;
                for(let i=0; i<count; i++) {
                    pos[i*3 + 1] -= vels[i];
                    if(pos[i*3 + 1] < -10) {
                        pos[i*3 + 1] = 10;
                        pos[i*3] = (Math.random()-0.5) * 25;
                        pos[i*3 + 2] = (Math.random()-0.5) * 10 - 5;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y = Math.sin(time * 0.2) * 0.05;
            }

            composer.render();
        }

        initScene();
        initVision();
        animate();
    </script>
</body>
</html>
